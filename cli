#!/usr/bin/env python

import argparse
import sys
import os.path
import logging

import sefi
import sefi.log

def opt_parser():

	parser = argparse.ArgumentParser(description='search binary data for sequences of instructions')

	parser.add_argument(
		'file', 
		nargs='?', 
		type=argparse.FileType('r'),
		help='file to search. if no file is given, stdin will be used',
		default=False
	)

	parser.add_argument(
		'-v', 
		'--verbose', 
		action='count', 
		help='print debug output. repeat to increase verbosity.',
		default=0
	)

	parser.add_argument(
		'-n',
		'--n',
		metavar='N',
		type=int,
		help='search backwards from gadget terminator for N bytes. default: 20',
		default=20
	)

	parser.add_argument(
		'-g',
		'--gadget',
		metavar='BYTES',
		action='append',
		help='search for gadgets ending in BYTES.',
		default=[]
	)

	parser.add_argument(
		'--ret',
		action='store_true',
		help='search for gadgets ending with a RET instruction (or anything logically equivalent to "pop %%sp; jmp %%sp").'
	)

	parser.add_argument(
		'--jmp-reg',
		action='store_true',
		help='search for gadgets ending with a "JMP %%reg" instruction.'
	)

	parser.add_argument(
		'--call-reg',
		action='store_true',
		help='search for gadgets ending with a "CALL %%reg" instruction.'
	)

	parser.add_argument(
		'--all',
		action='store_true',
		help='equivalent to passing --ret, --jmp-reg, and --call-reg.'
	)

	""" 
	TODO: parser.add_argument(
		'--raw',
		action='store_true', 
		help='treat the input as raw executable bytes (by default the input is parsed as an elf executable).'
	)
	"""
	
	return parser

class SefiCliErr(Exception):
	pass

class MissingOption(SefiCliErr):
	pass

class NotImplemented(SefiCliErr):
	pass

def validate_options(options):
	if len(options.gadget) < 1 and \
			not options.ret and \
			not options.jmp_reg and \
			not options.call_reg and \
			not options.all:
		raise MissingOption("you must specify at least one gadget specification: -g, --ret, --jmp-reg, --call-reg or --all")

def run(options):

	validate_options(options)
	
	lgr = logging.getLogger("sefi")
	if options.verbose >= 2:
		lgr.setLevel(logging.DEBUG)
	elif options.verbose == 1:
		lgr.setLevel(logging.INFO)
	else:
		lgr.setLevel(logging.ERROR)

	ch = logging.StreamHandler()
	ch.setLevel(lgr.level)
	lgr.addHandler(ch)
	sefi.log.set_logger(lgr)

	if not options.file:
		sys.stderr.write("using stdin as input file\n")
		#elftools needs to be able to seek
		#so we need to make stdin a normal file
		with open("/tmp/sefi-stdin", "w") as f:
			f.write(sys.stdin.read())
	
		options.file = open("/tmp/sefi-stdin", "r")
		
	run_elf(options)

def run_elf(options):
	
	result = []

	if options.ret or options.all:
		result += list(sefi.search_elf_for_ret_gadgets(options.file, options.n))
	
	if options.jmp_reg: 
		#result += list(sefi.search_elf_for_jmp_reg_gadgets(options.file, options.n))
		raise NotImplemented("jmp reg gadget search not implemented")

	if options.call_reg:
		raise NotImplemented("call reg gadget search not implemented")

	if len(options.gadget) > 0:
		raise NotImplemented("custom gadget search not implemented")

	cond_flow = []
	uncond_flow = []
	normal = []
	
	for g in result:
		#unconditional is the strongest condition
		if g.has_uncond_ctrl_flow():
			uncond_flow.append(g)
		elif g.has_cond_ctrl_flow():
			cond_flow.append(g)
		else:
			normal.append(g)

	print("gadgets with unconditional control flow:")
	display_gadgets(uncond_flow)
	print("\n")
	print("gadgets with conditional control flow:")
	display_gadgets(cond_flow)
	print("\n")
	print("gadgets with no control flow:")
	display_gadgets(normal)
	print("\n")


def display_gadgets(gadgets):
	width = 60

	for g in gadgets:
		print("-"*width)
		print(repr(g))
			

		
if __name__ == "__main__":
	opt_p = opt_parser()
	options = opt_p.parse_args()

	try:
		run(options)
	except SefiCliErr as e:
		print(e)
		print("")
		opt_p.print_help()
		exit(1)

