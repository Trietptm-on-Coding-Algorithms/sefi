#!/usr/bin/env python

import argparse
import sys
import os.path
import logging

import sefi
import sefi.log

def opt_parser():

	parser = argparse.ArgumentParser(description='search binary data for sequences of instructions')

	parser.add_argument(
		'file', 
		nargs='?', 
		type=argparse.FileType('r'),
		help='file to search. if no file is given, stdin will be used',
		default=False
	)

	parser.add_argument(
		'-v', 
		'--verbose', 
		action='count', 
		help='print debug output. repeat to increase verbosity.',
		default=0
	)

	parser.add_argument(
		'--raw',
		action='store_true', 
		help='treat the input as raw executable bytes (by default the input is parsed as an elf executable).'
	)

	parser.add_argument(
		'--nx', 
		action='store_true', 
		help='look for instructions in non-executable segments. ignored when --raw is used.'
	)

	return parser


class MissingOption(Exception):
	pass


def run(options):

	lgr = logging.getLogger("sefi")
	if options.verbose >= 2:
		lgr.setLevel(logging.DEBUG)
	elif options.verbose == 1:
		lgr.setLevel(logging.INFO)
	else:
		lgr.setLevel(logging.ERROR)

	ch = logging.StreamHandler()
	ch.setLevel(lgr.level)
	lgr.addHandler(ch)
	sefi.log.set_logger(lgr)

	if not options.file:
		#elftools needs to be able to seek
		#so we need to make stdin a normal file
		with open("/tmp/sefi-stdin", "w") as f:
			f.write(sys.stdin.read())
			f.close
		options.file = open("/tmp/sefi-stdin", "r")
		
	if not options.raw:
		result = list(sefi.search_elf_for_ret_gadgets(options.file))
		print("gadgets:")

		width = 60
		
		for gadget in result:
			print("-"*width)
			print("  %r" % (gadget))
			
			
	else:
		print("raw mode not yet implemented");
		exit(1)

		
if __name__ == "__main__":
	opt_p = opt_parser()
	options = opt_p.parse_args()

	try:
		run(options)
	except MissingOption as e:
		print(e)
		print("")
		opt_p.print_help()
		exit(1)

